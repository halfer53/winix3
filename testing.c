#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char const *argv[]) {
  int i = 0;
  int length = 0;
  int wordslength = 0;
  int temp = 0;
  int recordtype = 0;



  char *init_code[100][128] = {"S50300676a",
  "S60303e11b",
  "S32D00000000000003DA0000003F000003D10000006A000003CC00000075000003C900000035000003C40000002943",
  "S32D0000000A000003BF00000027000003B70000002500000000000000831EE3000497E000009CE000019DE0000205",
  "S32D000000148DE000049DE000031C0100212DC2000DB0D000058DE000033DD2007EB0D00002170100014000001F17",
  "S32D0000001E070100000101000787E000008CE000018DE000021EE1000450F000000101000050F0000001010000D9",
  "S32D0000002850F000001EE300039DE000009FE0000190E00002600002C60D0100019DE00002010100008DE00000D2",
  "S32D000000328FE000011EE1000350F000001EE300029DE000009FE00001600002B50D0100010101000D8DE000004C",
  "S32D0000003C8FE000011EE1000250F000001EE3000F94E0000695E0000796E0000897E000099BE0000A9CE0000BD5",
  "S32D000000469DE0000C9FE0000D600002910D0100010701000D1D01003C0476000D0546000D0656000D1C01001889",
  "S32D000000500B66000C9BE0000E0448000D0558000D0668000C17780064CD0003989DE000008DE0000E9DE000016E",
  "S32D0000005A96E0000295E0000394E0000497E00005600001A70101000084E0000685E0000786E0000887E00009D6",
  "S32D000000648BE0000A8CE0000B8DE0000C8FE0000D1EE1000F50F000001EE300039DE000019FE00002CD00037DEF",
  "S32D0000006E9DE00000600001A7010100008DE000018FE000021EE1000350F000001EE300039DE000019FE00002B9",
  "S32D00000078CD0003769DE00000600001A790E00000600002A20D0100010101000D8DE000018FE000021EE100031C",
  "S32D0000008250F000001EE300049DE000029FE000038DE000042DDA0000B0D000020101000040000093CD00035F0C",
  "S32D0000008C9DE000008DE000058DD000009DE00001600001A7310EFFFF111DFFFF8DE000028FE000031EE1000427",
  "S32D0000009650F000001EE3000B94E0000295E0000396E0000497E000059CE000069DE000079FE000080501000079",
  "S32D000000A090E0000090E000016000003F90E0000090E000016000002940000107CD0003579DE00000600001A754",
  "S32D000000AA06010000600001390D0100019D6004138D6004133DDA000DB0D00001400000C38D6004133DDA000895",
  "S32D000000B4B0D000082D680000B0D000048D6004139DE00000600001111662000116620001400000C08D60041394",
  "S32D000000BE9DE0000060000111166000013D600063B0DFFFE81D6000010601000D90D00413CD0003549DE000008E",
  "S32D000000C8600001A704010000C7000413400000EF177100018D7000009DE0000A2DD80000B0D000068DE0000AE1",
  "S32D000000D29DE00000600000100D0100012DD80000B0DFFFF58D7000002DD80000B0D000050D01000414D00001FE",
  "S32D000000DC97D003E1400000DF177100018D7000009DE000092DD80000B0D000068DE000099DE000006000001092",
  "S32D000000E60D0100012DDA0000B0DFFFF58D7000002DD80000B0D000030D01000717D1000190D000008D70000073",
  "S32D000000F02DDA0000B0DFFFDBC5000000400000F5155100028D5000009DE0000A0C01000D2DC90000B0D0000814",
  "S32D000000FA8D0003E19DE000008DE0000A9DE00001600001F70D0100012DDA0000B0DFFFF294E00000CD0003E1E2",
  "S32D000001049DE000018D50000170D00000400000A784E0000285E0000386E0000487E000058CE000068DE00007C0",
  "S32D0000010E8FE000081EE1000B50F000001EE300029CE000009DE000018DE000029DE000023D0E00071DDD0003C8",
  "S32D000001188DD000001DDB00022DD80000B0DFFFFA3D0E00071DDD00008CE000029CD00000010100008CE0000041",
  "S32D000001228DE000011EE1000250F000001EE300029CE000009DE000018DE000029DE000023D0E00071DDD1003B6",
  "S32D0000012C8DD000001DDB00022DD80000B0DFFFFA3D0E00071DDD10008CE000029CD00000010100008CE000001D",
  "S32D000001368DE000011EE1000250F000001EE300019DE000003D0E00071DDD00038DD000001DDB00012DD80000C3",
  "S32D00000140B0DFFFFA3D0E00071DDD000181D000008DE000001EE1000150F000001EE3000696E0000197E00002C7",
  "S32D0000014A9CE000039DE000049FE00005370E3B9A177DCA008DE000062DDA0000B0D000041D0100309DE00000C2",
  "S32D0000015460000111400001708DE000062DD60000B0D0000A1D01002D9DE00000600001113D0EFFFF1DDDFFFFDF",
  "S32D0000015E8CE000060DD4000C9DE00006400001631776000A8DE000062D72000DB0DFFFFC4000016E8DE000068B",
  "S32D0000016806D600071D68000A1DD000309DE00000600001111776000A2D7A0000B0DFFFF786E0000187E0000258",
  "S32D000001728CE000038DE000048FE000051EE1000650F000001EE3000596E0000197E000029DE000039FE00004CD",
  "S32D0000017C1701001C8DE000050DDE000716DB000F3D66000AB0D000041D6000309DE00000600001114000018A25",
  "S32D000001861D62000A1DD000419DE0000060000111177200042D760000B0DFFFF086E0000187E000028DE00003B7",
  "S32D000001908FE000041EE1000550F000001EE300049CE000019DE000029FE000034000019E8DE000041CD10001C9",
  "S32D0000019A9CE000048DD000009DE00000600001118DE000048DD000002DDA0000B0DFFFF68CE000018DE0000236",
  "S32D000001A48FE000031EE1000450F000001EE3000796E0000197E000029CE000039DE000049FE0000517E10007FD",
  "S32D000001AE17710001400001EB8DE000078DD000003DDA0025B0D000318DE000071DD100019DE000078DE0000755",
  "S32D000001B886D000001D0100739DE000062D68000DB0D000198DE000062D62000DB0D000033D680064B0D0000455",
  "S32D000001C2400001DE3D680078B0D00009400001DE8D7000009DE0000060000147177100018DE000071DD100011D",
  "S32D000001CC9DE00007400001EB8D7000009DE0000060000177177100018DE000071DD100019DE00007400001EB67",
  "S32D000001D68D7000009DE0000060000193177100018DE000071DD100019DE00007400001EB8DE000071CD100018F",
  "S32D000001E09CE000078DD000009DE0000060000111400001EB8DE000071CD100019CE000078DD000009DE0000037",
  "S32D000001EA600001118DE000078DD000002DDA0000B0DFFFC10101000086E0000187E000028CE000038DE000049C",
  "S32D000001F48FE000051EE1000750F000001EE300039CE000009DE00001400002088DE000038DD000008CE000049E",
  "S32D000001FE8CC000002DD8000CB0D00001400002138DE000031DD100019DE000038DE000041DD100019DE00004E0",
  "S32D000002080D0100009DE000028CE000038CC000002DC8000DB0D000058DE000048DD000008CE000022DDA000CAA",
  "S32D00000212B0DFFFE88DE000038DD000008CE000048CC0000001D2000C8CE000008DE000011EE1000350F00000C4",
  "S32D0000021C1EE3000397E000009CE000019DE000020701000040000223177000018DE000031CD100019CE000036B",
  "S32D000002268DD000002DDA0000B0DFFFF90101000787E000008CE000018DE000021EE1000350F000001EE300042C",
  "S32D000002309BE000009CE000019DE000028DE000049DE000034000023E8DE000041CD100019CE000048CE0000568",
  "S32D0000023A1BC100019BE000058CC000009CD000008DE000058DD000002DDA0000B0DFFFF48DE0000490D0000058",
  "S32D0000024481E000038BE000008CE000018DE000021EE1000450F000001EE3000496E0000097E000019CE000022D",
  "S32D0000024E9DE00003060100000701000040000253166000018DE000040D61000D8DD000002DDA0000B0DFFFFA0F",
  "S32D00000258400002610D6000078CE000040DD1000C8CE000050C71000C8CC000009CD00000177000018DE000055B",
  "S32D000002620D71000D8DD000002DDA0000B0DFFFF30D6000078CE000040DD1000C90D0000081E0000486E0000005",
  "S32D0000026C87E000018CE000028DE000031EE1000450F000001EE3000496E0000097E000019CE000029DE00003EA",
  "S32D00000276070100000601000087E00006400002828DE000040D61000D8CE000050C71000C8CC000009CD000007C",
  "S32D0000028016600001177000018DE000078CE000060DD0000C2D70000DB0DFFFF38DE000040D61000D90D000000B",
  "S32D0000028A0101000686E0000087E000018CE000028DE000031EE1000450F000001EE3000E9DE000029FE000033F",
  "S32D0000029490E000041D0100049DE0000690E000001DE100059DE00001600003410D0100019DE0000481E0000796",
  "S32D0000029E8DE000028FE000031EE1000E50F000001EE3000E9DE000029FE0000390E000041D0100059DE00006DA",
  "S32D000002A88DE0000E9DE0000790E000001DE100059DE00001600003410D0100019DE0000481E000078DE000022D",
  "S32D000002B28FE000031EE1000E50F000001EE3000E9DE000029FE0000390E0000D1D0100069DE0000590E00000BC",
  "S32D000002BC1DE100049DE00001600003200D0100019DE0000D010100008DE000028FE000031EE1000E50F0000048",
  "S32D000002C61EE3000E9DE000029FE0000390E0000D1D0100079DE0000590E000001DE100049DE000016000032063",
  "S32D000002D00D0100019DE0000D010100008DE000028FE000031EE1000E50F000001EE3000E9DE000029FE0000327",
  "S32D000002DA90E0000D1D0100079DE0000590E000001DE100049DE00001600003200D0100019DE0000D01010000C4",
  "S32D000002E48DE000028FE000031EE1000E50F000001EE3000E9DE000029FE0000390E000041D0100079DE0000692",
  "S32D000002EE8DE0000E9DE0000D90E000001DE100059DE00001600003410D0100019DE0000481E0000A8DE00002DE",
  "S32D000002F88FE000031EE1000E50F000001EE3000E9DE000029FE0000390E000041D01000B9DE000068DE0000E6E",
  "S32D000003029DE0000D90E000001DE100059DE00001600003410D0100019DE0000481E0000A8DE000028FE00003D2",
  "S32D0000030C1EE1000E50F000001EE3000E9DE000029FE0000390E000041D01000C9DE000068DE0000E9DE0000A43",
  "S32D0000031690E000001DE100059DE00001600003200D0100019DE000048DE000028FE000031EE1000E50F0000087",
  "S32D000003201EE300059DE000039FE000043D0E13371DDD00019DE000008DE000059DE000018DE000069DE00002B7",
  "S32D0000032A600003520D0100010101000D8DE000038FE000041EE1000550F000001EE300059DE000039FE00004A2",
  "S32D000003343D0E13371DDD00029DE0000090E000018DE000059DE00002600003520D0100010101000D8DE00003E8",
  "S32D0000033E8FE000041EE1000550F000001EE300059DE000039FE000043D0E13371DDD00039DE000008DE0000550",
  "S32D000003489DE000018DE000069DE00002600003520D0100010101000D8DE000038FE000041EE1000550F000001D",
  "S32D00000352200D000050F000000000000D0000000A0000000000000057000000490000004E00000049000000586A",
  "S32D0000035C0000003E0000002000000000000000550000006E0000006B0000006E0000006F000000770000006E25",
  "S32D0000036600000020000000630000006F0000006D0000006D000000610000006E00000064000000200000002723",
  "S32D000003700000002500000073000000270000000D0000000A000000000000004200000079000000650000002148",
  "S32D0000037A0000000D0000000A00000000000000500000006C000000610000006300000065000000680000006F82",
  "S32D000003840000006C00000064000000650000007200000020000000660000006F000000720000002000000053CA",
  "S32D0000038E000000480000005500000054000000440000004F000000570000004E0000000D0000000A0000000001",
  "S32D00000398000000550000007000000074000000690000006D0000006500000020000000690000007300000020A7",
  "S32D000003A20000002500000064000000640000002000000025000000640000006800000020000000250000006486",
  "S32D000003AC0000006D0000002000000025000000640000002E0000002500000064000000730000000D0000000ACC",
  "S32D000003B600000000000000740000006500000073000000740000006D000000610000006C0000000000000065BA",
  "S32D000003C000000078000000650000006300000000000000660000006F000000720000006B0000000000000070AD",
  "S32D000003CA0000007300000000000000650000007800000069000000740000000000000073000000680000007588",
  "S32D000003D400000074000000640000006F000000770000006E00000000000000750000007000000074000000690D",
  "S311000003DE0000006D00000065000000003B",
  "S7050000009763"};

  for ( i = 0; i < 2; i++) {
    temp = exec_phase1_readLength((*init_code)[i],&recordtype);
    if (recordtype != 0 && temp != -1) {
      if (recordtype == 5) {
        length = temp;

      }else if(recordtype == 6){
        wordslength = temp;
      }else{
        printf("incorrect initial record count\n" );
        return;
      }
    }
  }
  //first recordtype 5,and 6 is consumed


  i = exec_phase2(init_code,length,2,wordslength);
  printf("lenght %d\n",length );
  printf("wordsLoaded %d\n", i);

  return 0;

}
void assert(int expression, const char *message) {
	if(!expression) {
		printf("\r\nAssertion Failed ");
    printf("%s\r\n",message );
	}
}
int hex2int(char *a, int len)
{
    int i;
    int val = 0;

    for(i=0;i<len;i++){
			if(a[i] <= 57)
			 val += (a[i]-48)*(1<<(4*(len-1-i)));
			else
			 val += (a[i]-55)*(1<<(4*(len-1-i)));
		}

    return val;
}

int Substring(char* buffer,char* original,int start_index,int length){
	int i = 0;
	int count = 0;
	for(i = start_index; i<length+start_index; i++)
  {
        buffer[count] = original[i];
				count++;
  }
	buffer[count] = '\0';
	return count;
}

typedef unsigned char byte;

int exec_phase1_readLength(char *line, int* type){
  int i=0;

  int index = 0;
	int checksum = 0;
  byte byteCheckSum = 0;
	int recordType = 0;
	int byteCount = 0;
	char buffer[128];
	char tempBufferCount = 0;

  int wordsCount = 0;
  int length = 0;
  int readChecksum = 0;
  int data = 0;

        index = 0;
        checksum = 0;

				//printf("%s\r\n",line);
        //printf("loop %d\n",linecount );
				//Start code, always 'S'
				assert(line[index++] == 'S',"Expecting S");

				recordType = line[index++] - '0';
        if (recordType == 5 || recordType == 6) {
          *type = recordType;
        }else{
          printf("recordType %d\n",recordType );
          printf("format is incorrect\n" );
          return -1;
        }
        tempBufferCount = Substring(buffer,line,index,2);
				//printf("record value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
				byteCount = hex2int(buffer,tempBufferCount);
        index += 2;
        checksum += byteCount;

				assert(byteCount<255,"byteCount bigger than 255");

						tempBufferCount = Substring(buffer,line,index,(byteCount-1)*2 );
						//printf("temp byte value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
						data = hex2int(buffer,tempBufferCount);
            //printf("data %d\n", data);
            index += (byteCount-1)*2;
            checksum += data;

				//Checksum, two hex digits. Inverted LSB of the sum of values, including byte count, address and all data.
				//readChecksum = (byte)Convert.ToInt32(line.Substring(index, 2), 16);
        //printf("checksum %d\n",checksum );
				tempBufferCount = Substring(buffer,line,index,2);
				//printf("read checksum value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
				readChecksum = hex2int(buffer,tempBufferCount);
        // printf("readChecksum %d\n",readChecksum );
        // printf("checksum %d\n",checksum );
        //printf("checksum %d\r\n",checksum );
        if (checksum > 255) {
          byteCheckSum = (byte)(checksum & 0xFF);
          //printf("checksum %d\r\n",byteCheckSum );
          byteCheckSum = ~byteCheckSum;
        }else{
          byteCheckSum = ~byteCheckSum;
          byteCheckSum = checksum;
        }
        //printf("checksum %d\r\n",byteCheckSum );
				if (readChecksum != byteCheckSum){
					printf("failed checksum\r\n" );
					return -1;
				}
        return data;
}
//*(unsigned long*)FREE_MEM_BEGIN = (unsigned int)memVal;
//FREE_MEM_BEGIN++;
int exec_phase2(char *(*lines),int length,int lines_start_index,int wordsLength){
  // char* lines[] = {"S32D000000008107300090073004120000003828000DB08FFFFB600000096000000E1220000140000003810730038F",
	// 			"S32D0000000A91073002812000139107300350F000001901FFFF199A000219930001B09FFFFE50F0000000000076C3",
	// 			"S32D000000140000007900000038000000380000003F00000000000000390000005B0000003F0000003F0000000084",
	// 			"S30D0000001E0000000000000000D4",
	// 			"S70500000000FA"};
  char memValues[wordsLength];
  int wordsCount = 0;
	int wordsLoaded = 0;
	int index = 0;
	int checksum = 0;
  byte byteCheckSum = 0;
	int recordType = 0;
	int addressLength = 0;
	int byteCount = 0;
	char buffer[128];
	char tempBufferCount = 0;
	int address = 0;
	byte data[255];
	int readChecksum = 0;
	int datalength = 0;
	unsigned long memVal = 0;
  int i = 0;
  int j = 0;
  int linecount = lines_start_index;

	while(1){
		//Read line from terminal
		// for(i = 0; i < BUF_LEN - 1; i++) {
		// 	buf[i] = getc(); 	//read
    //
		// 	if(buf[i] == '\r') { //test for end
		// 		break;
		// 	}
		// 	putc(buf[i]); 		//echo
		// }

		char* line = lines[linecount];

    linecount++;
    index = 0;
    checksum = 0;

				//printf("%s\r\n",line);
        //printf("loop %d\n",linecount );
				//Start code, always 'S'
				assert(line[index++] == 'S',"Expecting S");

				//Record type, 1 digit, 0-9, defining the data field
				//0: Vendor-specific data
				//1: 16-bit data sequence
				//2: 24 bit data sequence
				//3: 32-bit data sequence
				//5: Count of data sequences in the file. Not required.
				//7: Starting address for the program, 32 bit address
				//8: Starting address for the program, 24 bit address
				//9: Starting address for the program, 16 bit address
				recordType = line[index++] - '0';

				switch (recordType)
				{
						case 0:
						case 1:
						case 9:
								addressLength = 2;
								break;

            case 5:
            case 6:
                addressLength = 0;
                break;

						case 2:
						case 8:
								addressLength = 3;
								break;

						case 3:
						case 7:
								addressLength = 4;
								break;

						default:
								printf("unknown record type");
								return 0;
				}
				tempBufferCount = Substring(buffer,line,index,2);
				//printf("record value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
				byteCount = hex2int(buffer,tempBufferCount);
        index += 2;
        checksum += byteCount;

				//byteCount = ((int)line[index++])*10 + ((int)line[index++]);
				//int byteCount = Convert.ToInt32(line.Substring(index, 2), 16);
				//printf("byteCount %d\r\n",byteCount);



				//Address, 4, 6 or 8 hex digits determined by the record type
				for (i = 0; i < addressLength; i++)
				{
						tempBufferCount = Substring(buffer,line,index+i*2,2);
						//printf("temp byte value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
						checksum += hex2int(buffer,tempBufferCount);
						//string ch = line.Substring(index + i * 2, 2);
						//checksum += Convert.ToInt32(ch, 16);
				}
        if (addressLength!=0) {
          tempBufferCount = Substring(buffer,line,index,addressLength*2);
  				//printf("temp address value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
  				address = hex2int(buffer,tempBufferCount);
        }


				//address = Convert.ToInt32(line.Substring(index, addressLength * 2), 16);
        //printf("index %d\n",index );
        index += addressLength * 2;
        //printf("index %d\n",index );
				byteCount -= addressLength ;
        //printf("byteCount %d\n",byteCount );
				//Data, a sequence of bytes.
				//data.length = 255
				assert(byteCount<255,"byteCount bigger than 255");
				for (i = 0; i < byteCount-1; i++)
				{
						tempBufferCount = Substring(buffer,line,index,2);
						//printf("temp byte value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
						data[i] = hex2int(buffer,tempBufferCount);
						//data[i] = (byte)Convert.ToInt32(line.Substring(index, 2), 16);
						index += 2;
						checksum += data[i];
				}

				//Checksum, two hex digits. Inverted LSB of the sum of values, including byte count, address and all data.
				//readChecksum = (byte)Convert.ToInt32(line.Substring(index, 2), 16);

				tempBufferCount = Substring(buffer,line,index,2);
				//printf("read checksum value %s, value in base 10: %d,length %d\r\n",buffer,hex2int(buffer,tempBufferCount),tempBufferCount);
				readChecksum = hex2int(buffer,tempBufferCount);
        //printf("checksum %d\r\n",checksum );
				byteCheckSum = (byte)(checksum & 0xFF);
        //printf("checksum %d\r\n",byteCheckSum );
        byteCheckSum = ~byteCheckSum;
        //printf("checksum %d\r\n",byteCheckSum );
				if (readChecksum != byteCheckSum){
					printf("failed checksum\r\n" );
					return;
				}

				//Put in memory
				assert((byteCount-1) % 4 == 0, "Data should only contain full 32-bit words.");
        //printf("recordType %d\n", recordType);
        //printf("%lu\n",(unsigned long)data[0] );
        //printf("byteCount %d\n",byteCount );
        switch (recordType)
				{
						case 3: //data intended to be stored in memory.

								for (i = 0; i < byteCount-1; i += 4)
								{
										memVal = 0;
										for (j = i; j < i + 4; j++)
										{

												memVal <<= 8;
												memVal |= data[j];
                        	//printf("0x%08x\n",(unsigned int)memVal );
										}
                    memValues[wordsLoaded] = memVal;
										wordsLoaded++;

                    if (wordsLoaded > wordsLength) {
                      printf("words exceed max length\n" );
                      return;
                    }
										printf("0x%08x,\n",(unsigned int)memVal );
                    //printf("%d,\n",(unsigned int)memVal );
								}

								break;


						case 7: //entry point for the program.
								// CPU.PC = (uint)address;
                printf("addr 0x%08x\n", (unsigned int)address);
								break;
				}
        if (linecount >= length) {
          break;
        }
		}

		return wordsLoaded;

}
